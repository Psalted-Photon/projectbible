import fs from "node:fs";
import path from "node:path";
import Database from "better-sqlite3";

const repoRoot = path.resolve(".");
const bootstrapPath = path.join(repoRoot, "packs", "bootstrap.sqlite");
const outputPath = path.join(repoRoot, "packages", "core", "src", "BibleMetadata.ts");

if (!fs.existsSync(bootstrapPath)) {
  console.error(`Missing bootstrap.sqlite at ${bootstrapPath}`);
  process.exit(1);
}

const db = new Database(bootstrapPath, { readonly: true });

const books = db.prepare("SELECT id, name, chapter_count FROM books ORDER BY book_order").all();
const verseRows = db.prepare("SELECT book_id, chapter, verse_count FROM chapter_verses").all();

const verseCountsByBookId = new Map();
for (const row of verseRows) {
  if (!verseCountsByBookId.has(row.book_id)) {
    verseCountsByBookId.set(row.book_id, new Map());
  }
  verseCountsByBookId.get(row.book_id).set(row.chapter, row.verse_count);
}

const verseCountsByName = {};
for (const book of books) {
  const counts = [];
  const chapterMap = verseCountsByBookId.get(book.id) ?? new Map();
  for (let chapter = 1; chapter <= book.chapter_count; chapter += 1) {
    counts.push(chapterMap.get(chapter) ?? 0);
  }
  verseCountsByName[book.name] = counts;
}

db.close();

const content = `// Auto-generated by scripts/generate-verse-counts.mjs
// Source: bootstrap.sqlite chapter_verses

export const VERSE_COUNTS: { [book: string]: number[] } = ${JSON.stringify(
  verseCountsByName,
  null,
  2,
)};
`;

fs.writeFileSync(outputPath, content, "utf8");
console.log(`âœ… Wrote verse counts to ${outputPath}`);
